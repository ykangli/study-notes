# 垃圾回收

------

## 什么是垃圾？

垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。

Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 **堆** 内存中对象的分配与回收。

重点关注哪些区域的回收？

![image-20220326113700199](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220326113700199.png)

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**。

## 垃圾回收相关算法

### 垃圾标记阶段（对象存活判断）

当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。

判断对象存活一般有两种方式：**引用计数法**和**可达性分析算法**。

#### 引用计算算法

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。

优点：实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。

缺点：很难解决对象之间相互循环引用的问题

![image-20220326115102441](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220326115102441.png)

#### 可达性分析算法（JVM中所使用的）

这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，🔥**当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收**。

下图中的 `Object 5 ~ Object 7` 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。

<img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220326115241488.png" alt="image-20220326115241488" style="zoom: 80%;" />

#### **哪些对象可以作为 GC Roots 呢？** 🔥🔥🔥高频考题

- 虚拟机栈(栈帧中的本地变量表)中**引用的对象**
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象     如Java类的引用类型静态变量
- **方法区中常量引用的对象**
- 所有被**同步锁持有的对象**

💡 记忆小技巧：由于Root采用栈方式存放变量和指针，所以如果一个指针，它**保存了堆内存里面的对象，但自己又不存放在堆内存里**面，那它就是一个Root。

除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整Gc Roots集合。比如:分代收集和局部回收(Partial Gc）。

- 如果只针对Java堆中的某一块区域进行垃圾回收（比如:典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，史个是孤立封闭的，这个区域的对象完全有可能被其他区域的对家所用，rP候就需要一并将关联的区域对象也加入GC Roots集合中去考虑,才能保证可达性分析的准确性。

### 使用JProfiler分析OOM

![image-20220326161330198](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220326161330198.png)

![image-20220326161604698](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220326161604698.png)

### 清除阶段相关算法

#### 标记-清除算法

该算法分为“标记”和“清除”阶段：首先**标记出所有不需要回收的对象**，在标记完成后**统一回收掉所有没有被标记的对象**。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。

<img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220326162935424.png" alt="image-20220326162935424" style="zoom:67%;" />

执行过程：

当堆中有效内存空间被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项是标记，第二项是清除。

**标记**：Collector 从**引用根节点开始遍历**，**标记所有被引用的对象**。一般是在对象的Header中记录为**可达的对象**。

**清除**：Collector对堆内存从头到尾进行现象的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。

这种垃圾收集算法会带来两个明显的问题：

1. **效率问题**
2. 在进行GC时，需要停止整个应用程序（STW），导致用户体验差。
3. **空间问题（标记清除后会产生大量不连续的碎片）**

#### 标记-复制算法

为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

<img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220326163108979.png" alt="image-20220326163108979" style="zoom:67%;" />

#### 标记-整理算法

根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

![image-20220326163902807](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220326163902807.png)

#### 分代收集算法

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

比如在新生代中，每次收集都会有大量对象死去（朝生夕死），所以可以选择”**标记-复制**“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集（**因为标记的是不需要回收的对象，占少数**）。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“**标记-清除”或“标记-整理”算**法进行垃圾收集。

**延伸面试问题：** HotSpot 为什么要分为新生代和老年代？ **根据各个年代的特点选择合适的垃圾收集算法。**

#### 增量收集算法

上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the world的状态。在stop the world 状态下，应用程序所有的线程都会挂起暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集(Incremental Collecting）算法的诞生。

**基本思想** （洗衣服不要攒一堆再洗，一次洗一点）

如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程**只收集一小片区域的内存空间，接着切换到应用程序线程**。依次反复，直到垃圾收集完成。
总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。

缺点：线程切换和上下文转换消耗，使得垃圾回收总体成本上升，造成系统吞吐量下降。

## 垃圾回收相关概念

### System.gc()的理解

在默认情况下，通过System.gc()会显式的出发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。

### 内存溢出与内存泄露

### 内存溢出（OOM）

javadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。

**Java虚拟机的堆内存不够，原因有二：**

- Java虚拟机的堆内存设置不够
- 代码中创建了大量对象，，并且长时间不能被垃圾收集器收集（存在引用）

### 内存泄漏（Memory Leak）

严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们，才叫内存泄露。

内存泄露有可能导致内存溢出。

![image-20220327201647207](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220327201647207.png)

内存泄漏举例:

1. 单例模式 

   单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。

2. 一些提供close的资源未关闭导致内存泄漏

​		**数据库连接**（dataSourse.getConnection())，**网络连接**(socket)和io连接必须手动close，否则是不能被回收的。

### STW

Stop-the-World ，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。**停顿产生时整个应用程序线程都会被暂停**，没有任何响应有点像卡死的感觉，这个停顿称为STW。

>可达性分析算法中枚举根节点(GC Roots）会导致所有Java执行线程停顿。

- [x] 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
- [x] 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性

被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少sTw的发生。

### 程序的并发和并行

并发：

![并发](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220327202642842.png)

并行：

![image-20220327202735448](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220327202735448.png)

### 垃圾回收的并发与并行

并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下:

并发(Concurrent):指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），**垃圾回收线程在执行时不会停顿用户程序的运行**。
>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上;
>
>如:CMS、G1

![image-20220327203205180](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220327203205180.png)

绿色为应用线程，红色为GC线程

## 垃圾回收器

**如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**

### Serial 收集器

Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

![image-20220327204841991](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220327204841991.png)

### Serial Old 收集器

**Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。

### ParNew 收集器

**ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。**

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

![image-20220327204901104](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220327204901104.png)

它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，**只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。**

### Parallel Scavenge 收集器

Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 **那么它有什么特别之处呢？**

Parallel Scavenge 收集器关注点是**吞吐量（高效率的利用 CPU）**。CMS 等垃圾收集器的关注点更多的是**用户线程的停顿时间（提高用户体验）。**所谓**吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值**。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

![image-20220327204957183](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220327204957183.png)

**这是 JDK1.8 默认收集器**

### Parallel Old 收集器

**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

###  CMS 收集器

CMS（Concurrent Mark Sweep）收集器是一种**以获取最短回收停顿时间为目标的收集器**。它非常符合在**注重用户体验的应用上使用**。

CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它**第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程（**STW**），并记录下**直接与 root 相连的对象**，速度很快 ；
- **并发标记：** **同时开启 GC 和用户线程**，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。

- **重新标记：** 重新标记阶段就是为了**修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录**，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。**该环节需要执行STW机制。**

​		**如果在重新标记之前刚好发生了一次MinorGC，会不会导致重新标记阶段Stop the World时间太长？**

​		答：不会的，在并发标记阶段其实还包括了一次并发的**预清理阶段**，虚拟机会主动**等待年轻代发生垃圾回收**，这样可以将重新标记对象引用关系的步骤放在并		发标记阶段，有效降低重新标记阶段Stop The World的时间。

- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![image-20220327205140213](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220327205140213.png)

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- 对 CPU 资源敏感	因为并发标记和并发清理阶段和用户线程一起运行，当CPU数变小时，性能容易出现问题。
- 无法处理浮动垃圾；
- 它使用的回收算法-“标记-清除”算法会导致收集结束时会**有大量空间碎片产生**。

### G1 收集器

G1 (Garbage-First) 是一款**面向服务器的垃圾收集器**,主要针对配备**多CPU及大容量内存**的机器. 以**极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征**.

**JDK 9之后的默认垃圾回收器。**

具备以下特点：

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记-清理”算法不同，**G1 从整体来看是基于“标记-整理”算法**实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

### ZGC 收集器

与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。

在 ZGC 中出现 Stop The World 的情况会更少！