# JVM面试题

## 说一下 JVM 的主要组成部分及其作用？

![在这里插入图片描述](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/e62b850a7a814c31afb0f8eb693c1362.png)

JVM包含**两个子系统和两个组件**，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。

- Class loader(类装载)：加载类文件到内存
- Execution engine（执行引擎）：执行classes中的指令，也成为解释器，负责解释指令，交由操作系统执行
- Native Interface(本地接口)：与本地方法库交互，是其它编程语言交互的接口。 
- Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。

## JVM中的内存是怎么划分的？

![image-20220324210322103](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220324210322103.png)

**方法区：**方法区是一个**线程之间共享**的区域。**常量，静态变量以及JIT编译后的代码都在方法区。主要用于存储已被虚拟机加载的类信息**，也可以称为“永久代”，垃圾回收效果一般，通过-XX：MaxPermSize控制上限。

**堆内存：**堆内存是**垃圾回收**的主要场所，也是线程之间共享的区域，主要用来**存储创建的对象实例**，通过-Xmx 和-Xms 可以控制大小。

**虚拟机栈（栈内存）：**栈内存中主要保存**局部变量、基本数据类型变量**以及**堆内存中某个对象的引用变量**。每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表，操作数栈，动态链接，方法出口等信息。栈中的栈帧随着方法的进入和退出有条不紊的执行着出栈和入栈的操作。

**程序计数器：** 程序计数器是当前线程执行的**字节码的位置指示器**。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，是内存区域中唯一一个在虚拟机规范中**没有规定任何OutOfMemoryError情况**的区域。

**本地方法栈：** 主要是为JVM提供使用本地方法的服务。

## JVM的内存模型，Java 8做了什么修改？



## 线程之间有哪些东西是不能共享的？

虚拟机栈、程序计数器、本地方法栈

## 对象进入老年代有哪些情况？



## 什么情况会发生栈内存溢出？

栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型 

如果**线程请求的栈深度大于虚拟机所允许的最大深度**，将抛出StackOverflowError异常，方法递归调用产生这种结果。 

如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将抛出一个OutOfMemory 异常。(线程启动过多) 

参数 -Xss 去调整JVM栈的大小

## Java内存泄漏和内存溢出是什么，如何避免？

**内存泄漏**：指程序中动态分配给内存一些临时对象，并且这些对象始终没有被回收，一直占用着内存，简单来说就是申请内存使用完了不进行释放

常见的内存泄漏产生原因：

- **静态集合类引起内存泄漏**，因为静态集合的生命周期和JVM一致，所以静态集合引用的对象不能被释放 
- **单例模式导致内存泄漏**，因为单例模式的静态特性，它的生命周期和JVM的生命周期一致，如果单例对象持有外部对象的引用，这个对象也不会被回收 
- **内部类的对象被长期持有**，那么内部类对象所属的外部类对象也不能被收回 
- **数据库连接、网络连接等各种连接没有显示释放导致内存泄漏**，例如在数据库连接后不再使用时，必须调用close方法释放与数据库的连接，否则会造成大量对象无法被回收进而造成内存泄漏 
- **改变哈希值**，例如在一个对象存储到HashSet后，改变了对象中参与计算哈希值的字段，那么会导致对象的哈希值发生变化，和之前存入HashSet的哈希值不同，也就无法通过当前对象的引用在HashSet中找到这个对象，无法从HashSet中删除对象，造成内存泄漏，这也是为什么通常利用String类型的变量当作HashMap的key，因为String类型是不可变的 

内存泄漏解决方案：写代码时尽量避免上述会造成内存泄漏的情况

**内存溢出**：指程序运行过程中无法申请到足够的内存导致的错误

常见的造成内存溢出的原因：

- 内存加载的数据量太大，内存不够用了 
- 代码中存在死循环或循环产生大量对象 
- 启动参数内存值设置过小 
- 长期的内存泄漏也会导致内存溢出 

内存溢出解决方案：

- 修改JVM启动参数，增加内存 
- 使用内存查看工具动态查看内存使用情况 
- 对代码进行排查，重点排查有没有上述提到的造成常见内存溢出情景的代码

## JVM堆内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor？



## Eden和Survivor的比例分配？



## 强制Young GC会有什么问题？

STW停顿时间变长

## Minor GC 与 Full GC 分别在什么时候发生？(Minor GC 与 Full GC触发条件)

对象优先在Eden中分配，**当Eden中没有足够空间时，虚拟机将发生一次Minor GC**，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快。

Full GC是指发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。

发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小。如果大于，则不会进行Minor GC，而是进行一次**Full GC（老年代GC）**，如果小于，则查看**HandlePromotionFailure设置是否允许担保失败**，如果允许，那只会进行一次**Minor GC**，如果不允许，则改为进行一次**Full GC**。或者，如果有perm gen的话，要**在perm gen分配空间但已经没有足够空间时，也要触发一次full gc**。

发生Minor GC时，**虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小**？ 怎么理解？？？？

比较的是之前晋升的对象大小的平均值，就像一个大小为100的空间已经晋升了10个对象，占了95大小的空间，那平均值就是9.5，这时候剩余空间就只剩5，5小于9.5，所以要进行一次full GC。就是说下一次可能晋升的大小是9.5，但老年代剩余只有5，所以进行full gc

《深入理解 Java 虚拟机》第三章对于空间分配担保的描述如下：

> JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 `-XX:HandlePromotionFailure` 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 `-XX: HandlePromotionFailure` 设置不允许冒险，那这时就要改为进行一次 Full GC。
>
> JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。

## new一个对象的过程？

## **如和判断一个对象是否存活?(或者** **GC** **对象的判定方法)**

## new出来的对象是放在哪里（堆里），是一创建出来就进入堆中的吗？

## 创建出来的对象一定是放在堆中吗？

不一定。用`" "`创建的字符串对象就是放在字符串常量池中的，JDK 7之前字符串常量池在方法区中，JDK 之后字符串常量池被移到堆中。

![image-20220323203150001](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220323203150001.png)

![image-20220323203212611](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220323203212611.png)

## 对象在JVM中是怎么存储的？

## 对象头信息里面有哪些东西？（Java对象头里有什么？）

## 几种常用的内存调试工具：jmap、jstack、jconsole、jhat 、jstack

## TLAB知道吗？