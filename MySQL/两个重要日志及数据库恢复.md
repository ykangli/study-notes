---
title: 02 | 日志系统：一条SQL更新语句是如何执行的？（数据库使用InnoDB恢复原理）
date: 2022-01-13 13:51:19
categories: database
img: https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/s8958042.jpg
---

# 两个重要日志及数据库恢复

一条更新语句的执行流程又是怎样的呢？

之前你可能经常听 DBA 同事说，MySQL 可以恢复到半个月内任意一秒的状态，惊叹的同时，你是不是心中也会不免会好奇，这是怎样做到的呢？

我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 age：

```sql
mysql> create table T(ID int primary key, age int);
```

如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写：

```sql
mysql> update T set age=age+1 where ID=2;
```

前面我有跟你介绍过 SQL 语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。

<img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="MySQL 的逻辑架构图" style="zoom:33%;" />



执行语句前要先连接数据库，这是连接器的工作。

前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。

接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。

与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：`redo log（重做日志）`和` binlog（归档日志）`。

## 重要的日志模块：redo log

不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。

如果有人要赊账或者还账的话，掌柜一般有两种做法：

- 一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；
- 另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。

在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。

这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？

同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。

而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 `WAL 技术`，WAL 的全称是 `Write-Ahead Logging`，它的关键点就是**先写日志，再写磁盘**，也就是先写粉板，等不忙的时候再写账本。

具体来说，当有一条记录需要更新的时候，`InnoDB `引擎就会**先把记录写到 redo log**（粉板）里面，**并更新内存**，这个时候更新就算完成了。同时，`InnoDB `引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。

如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。

与此类似，**InnoDB 的 redo log 是固定大小的**，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头**循环写**，如下面这个图所示。

<img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/16a7950217b3f0f4ed02db5db59562a7.png" alt="" style="zoom: 67%;" />

**write pos** 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。**checkpoint** 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。

write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。

有了 redo log，`InnoDB` 就**可以保证即使数据库发生异常重启，之前提交的记录都不会丢失**，这个能力称为 **crash-safe**。

要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。

## 重要的日志模块：binlog

前面我们讲过，MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 **redo log 是 `InnoDB `引擎特有的日志**，而 Server 层也有自己的日志，称为 `binlog`（归档日志）。

为什么会有两份日志呢？

因为最开始 MySQL 里并没有` InnoDB `引擎。MySQL 自带的引擎是 `MyISAM`，但是` MyISAM `没有 crash-safe 的能力，`binlog `日志只能用于归档。而` InnoDB `是另一个公司以插件形式引入 MySQL 的，既然只依靠 `binlog `是没有 crash-safe 能力的，所以 `InnoDB` 使用另外一套日志系统——也就是 **redo log 来实现 crash-safe 能力**。

## redo log 和 binlog的区别

两种日志有以下三点不同。

1. redo log 是 InnoDB 引擎特有的；**binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用**。redo log 是**物理日志**，记录的是“在某个数据页上做了什么修改”；
2. binlog 是**逻辑日志**，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 age字段加 1 ”。**redo log 是循环写的，空间固定会用完**；
3. binlog 是可以**追加写**入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，**并不会覆盖以前的日志**。

## **update 语句的执行流程**

### **update 语句执行流程图**

图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。

<img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="update 语句的执行流程图" style="zoom:67%;" />

### update 语句执行步骤

1. 执行器：找存储引擎取到 id = 2 这一行记录

2. 存储引擎：根据主键索引树找到这一行，如果 id = 2 这一行所在的数据页本来就在内存池（Buffer Pool）中，就直接返回给执行器；否则，需要先从磁盘读入内存池，然后再返回

3. [执行器](https://www.zhihu.com/search?q=执行器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2280710259})：拿到存储引擎返回的行记录，把 age 字段加上 1，得到一行新的记录，然后再调用存储引擎的接口写入这行新记录

4. 存储引擎：将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 `prepare` 状态。然后告知执行器执行完成了，随时可以提交事务

   注意:不要把这里的提交事务和我们 sql 语句中的提交事务 commit 命令搞混了哈，我们这里说的提交事务，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，commit 命令就执行成功了。

5. 执行器：生成这个操作的 bin log，并把 bin log 写入磁盘

6. 执行器：调用存储引擎的提交事务接口

7. 存储引擎：把刚刚写入的 redo log 状态改成提交（`commit`）状态，更新完成

请格外注意和理解为什么将` redo log `的写入拆成了**两个步骤**：`prepare `和 `commit`，这就是**"两阶段提交"**。

为什么这样设计就能**实现数据库崩溃后还能恢复数据**呢？

## 为什么说 redo log 具有崩溃恢复的能力

redo log 和 bin log 的一个很大的区别就是，一个是**循环写**，一个是追加写。也就是说 **redo log 只会记录未刷入磁盘的日志**，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。

而 bin log 是追加日志，**保存的是全量的日志**。这就会导致一个问题，那就是没有标志能让 InnoDB 从 bin log 中判断哪些数据已经刷入磁盘了，哪些数据还没有。

举个例子，bin log 记录了两条日志：

```
记录 1：给 id = 1 这一行的 age 字段加 1
记录 2：给 id = 1 这一行的 age 字段加 1
```

假设在记录 1 刷盘后，记录 2 未刷盘时，数据库崩溃。重启后，只通过 bin log 数据库是无法判断这两条记录哪条已经写入磁盘，哪条没有写入磁盘，不管是两条都恢复至内存，还是都不恢复，对 id = 1 这行数据来说，都是不对的。

但 redo log 不一样，只要刷入磁盘的数据，都会从 redo log 中被抹掉，数据库重启后，直接把 redo log 中的数据都恢复至内存就可以了。

这就是为什么说 **redo log 具有崩溃恢复的能力，而 bin log 不具备**。

## 崩溃恢复时的判断规则

根据两阶段提交，**崩溃恢复时的判断规则**是这样的：

1. 如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交
2. 如果 redo log 里面的事务处于 prepare 状态，则判断对应的事务 binlog 是否存在并完整

- a. 如果 binlog 存在并完整，则提交事务；
- b. 否则，回滚事务。

### 数据库崩溃例一

如下图所示，假设数据库在**写入 redo log(prepare) 阶段之后、写入 binlog 之前**，发生了崩溃，此时 redo log 里面的事务处于 prepare 状态，binlog 还没写（对应 2b），所以崩溃的时候，这个事务会回滚。

<img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/v2-a26e4c7c6d2e1c89ed9c2296798e7899_720w.jpg" alt="img" style="zoom: 67%;" />

原因：

此时 redo log 里面的事务处于 prepare 状态，binlog 还没写，之后从库进行同步的时候，无法执行这个操作，但是实际上主库已经完成了这个操作，所以为了主备一致，MySQL 崩溃时会在主库上回滚这个事务。并且，由于 binlog 还没写，所以也就不会传到备库，从而避免主备不一致的情况。

### 数据库崩溃例二

如果数据库在写入 binlog 之后，redo log 状态修改为 commit 前发生崩溃，此时 redo log 里面的事务仍然是 prepare 状态，binlog 存在并完整（对应 2a），所以即使在这个时刻数据库崩溃了，事务仍然会被正常提交。

<img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/v2-94ec46b4b750cdf6bd913b5d9eedcb53_720w.jpg" alt="img" style="zoom:67%;" />

原因：

因为 binlog 已经写入成功了，这样之后就会被从库同步过去，但是实际上主库并没有完成这个操作，所以为了主备一致，在[主库](https://www.zhihu.com/search?q=主库&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2280710259})上需要提交这个事务。

## redo log **两阶段提交的必要性**

可不可以先 redo log 写完，再写 bin log 或者反过来？

### 1）对于先写完 redo log 后写 bin log 的情况：

<img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/v2-b690e860bdb751e57e14af362ba16647_720w.jpg" alt="img" style="zoom:67%;" />

假设在 **redo log 写完，binlog 还没有写完**的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 age 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。

因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。

### 2）对于先写完 binlog 后写 redo log 的情况：

<img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/v2-df3f63c6451613af1dcc4324677f1e4f_720w.jpg" alt="img" style="zoom:67%;" />

如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。

## 总结

Bin log 用于记录了完整的逻辑记录，所有的逻辑记录在 bin log 里都能找到，所以在备份恢复时，是以 bin log 为基础，通过其记录的完整逻辑操作，备份出一个和原库完整的数据。

## 面试造火箭计划！！！

1. redo log的概念是什么? 为什么会存在.

   答： redo log是重做日志。主要用于MySQL异常重启后的一种数据恢复手段，确保了数据的一致性。归根到底是MySQL为了实现WAL机制的一种手段。因为MySQL进行更新操作，为了能够快速响应，所以采用了异步写回磁盘的技术，写入内存后就返回。但是会存在crash后内存数据丢失的隐患，而redo log具备crash safe能力。

2. 什么是`WAL(write-ahead log)`机制, 好处是什么.

   答： WAL机制是**先写日志，再写磁盘**。也就是MySQL更新操作后在真正把数据写入到磁盘前先记录日志。好处是不用每一次操作都实时把数据写盘，就算crash后也可以通过redo log重放恢复，所以能够实现快速响应SQL语句。

3. redo log 为什么可以保证crash safe机制.

   答： 因为redo log是每次更新操作完成后，就一定会写入的，如果写入失败，这说明此次操作失败，事务也不可能提交。redo log内部结构是基于页的，记录了这个页的字段值变化，只要crash后读取redo log进行重放就可以恢复数据。（因为redo log是循环写的，如果满了InnoDB就会执行真正写盘）

4. binlog的概念是什么, 起到什么作用, 可以做crash safe吗?

   答：  bin log是归档日志，属于MySQL Server层的日志。可以起到全量备份的作用。当需要恢复数据时，可以取出某个时间范围内的bin log进行重放恢复。但是bin log不可以做crash safe，因为crash之前，bin log可能没有写入完全MySQL就挂了。所以需要配合redo log才可以进行crash safe。

5. binlog 和 redolog的不同点有哪些?

   答案：参考上面笔记。

6. 物理一致性和逻辑一直性各应该怎么理解?

   答: binlog 是逻辑日志，可以给别的数据库，别的引擎使用，已经大家都讲得通这个“逻辑”；redolog是物理日志，就只有“我”自己能用，别人没有共享我的“物理格式”

7. 执行器和innoDB在执行update语句时候的流程是什么样的?

   答案：参考上面笔记。

8. 如果数据库误操作, 如何执行数据恢复?

   答：数据库在某一天误操作，就可以找到距离误操作最近的时间节点前的bin log，重放到临时数据库里，然后选择当天误删的数据恢复到线上数据库。

9. 什么是两阶段提交, 为什么需要两阶段提交, 两阶段提交怎么保证数据库中两份日志间的逻辑一致性(什么叫逻辑一致性)?

   答案：参考上面笔记。

10. 如果不是两阶段提交, 先写redo log和先写bin log两种情况各会遇到什么问题?

    答案：参考上面笔记。

## 一些名词

数据页 ：MySQL的记录是以“页”为单位存取的，默认大小16K。也就是说，你要访问磁盘中一个记录，不会只读这个记录，而会把它所在的16K数据一起读入内存
