# 贪心算法

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。

## 贪心算法步骤

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

## [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**示例 1:**

```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

**示例 2:**

```
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```

**提示：**

- `1 <= g.length <= 3 * 104`
- `0 <= s.length <= 3 * 104`
- `1 <= g[i], s[j] <= 231 - 1`

为了了满足更多的小孩，就不要造成饼干尺寸的浪费。

大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。

**这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩**。

可以尝试使用贪心策略，先将饼干数组和小孩数组排序。

然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        int num = 0;
        Arrays.sort(g);
        Arrays.sort(s);
        int k = s.length - 1;
        for(int i = g.length - 1; i >= 0 ; i-- ) {
            if(k >= 0 && s[k] >= g[i]) {
                num++;
                k--;
            }
        }
        return num;  
    }
}
```

## [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

难度中等623收藏分享切换为英文接收动态反馈

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

**示例 1：**

```
输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
```

**示例 2：**

```
输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
```

**示例 3：**

```
输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2
```

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`

**进阶：**你能否用 `O(n)` 时间复杂度完成此题?

![376.摆动序列](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/20201124174327597.png)

**局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值**。

**整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列**。

局部最优推出全局最优，并举不出反例，那么试试贪心！

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if(nums.length <= 1) {
            return nums.length;
        }
        if(nums.length == 2 && nums[0] != nums[1]) {
            return nums.length;
        } else if(nums.length == 2 && nums[0] == nums[1]) {
            return 1;
        } 
        int result = 1;
        int preDiff = 0;
        int currDiff = 0;
        for(int i = 1; i < nums.length; i++) {
            currDiff = nums[i] - nums[i - 1];
            //preDiff >= 0说明一直在递增，preDiff <= 0说明一直在递减
            //如果中途 3——3，preDiff是不会更新的
            if((preDiff >= 0 && currDiff < 0) || (preDiff <= 0 && currDiff >0)) {
                result++;
                preDiff = currDiff;
            }
        }
        return result;
    }
}
```

## [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

**提示：**

- `1 <= nums.length <= 3 * 104`
- `0 <= nums[i] <= 105`

其实跳几步无所谓，关键在于可跳的覆盖范围！

不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。

**那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！**

每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。

**贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点**。

```java
class Solution {
    public boolean canJump(int[] nums) {
        //最大覆盖范围
        int maxRange = 0;
        for(int i = 0; i <= maxRange; i++) {
            maxRange = Math.max(maxRange, i + nums[i]);
            if(maxRange >= nums.length - 1)  {
                return true;
            }
        }
        return false;
    }
}
```

## [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

给你一个非负整数数组 `nums` ，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

**示例 1:**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**

```
输入: nums = [2,3,0,1,4]
输出: 2
```

**提示:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`

**每次在可跳范围内选择后续可以使得跳的更远的位置。**

**以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数！**

开始的位置是 2，可跳的范围是橙色的。然后因为 3 可以跳的更远，所以选择跳到 3 的位置。

![image-20220322095703220](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220322095703220.png)

如下图，然后现在的位置就是 3 了，能跳的范围是橙色的，然后因为 4 可以跳的更远，所以下次选择跳到 4 的位置。

![image-20220322095718567](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220322095718567.png)

![image-20220322110644087](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220322110644087.png)

```java
class Solution {
    public int jump(int[] nums) {
        int jumpNum = 0;
        //当前覆盖的最远距离
        int currRange = 0;
        //下一个能覆盖的最远范围
        int nextRange = 0;
        for(int i = 0; i < nums.length - 1; i++) {
            nextRange = Math.max(nextRange, i + nums[i]);
            //当前最远覆盖范围不包括最后的位置，那么需要进行如下一个覆盖范围，jumpNum++
            if(i == currRange ) {
                jumpNum++;
                currRange = nextRange;
            }
        }
        return jumpNum;
    }
}
```

i 只需要取到 nums.length - 2 （倒数第二个位置），因为当 i == nums.length - 2 时有**两种可能**：

1. 当前范围已经覆盖最后的位置，跳跃次数不会改变；
2. 当前范围未覆盖最后的位置，则jumpNum++;

## [135. 分发糖果](https://leetcode-cn.com/problems/candy/)

难度困难795收藏分享切换为英文接收动态反馈

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

**示例 1：**

```
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

**示例 2：**

```
输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
```

**提示：**

- `n == ratings.length`
- `1 <= n <= 2 * 104`
- `0 <= ratings[i] <= 2 * 104`

![image-20220324152318272](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220324152318272.png)

```java
class Solution {
    public int candy(int[] ratings) {
        int[] left = new int[ratings.length];
        int[] right = new int[ratings.length];
        int[] result = new int[ratings.length];
        int sum = 0;
        Arrays.fill(left, 1);
        Arrays.fill(right, 1);
        //从左到右比较，满足当前位置比左边分数高就要比左边多一个糖果
        for(int i = 1; i < left.length; i++) {
            if(ratings[i] > ratings[i - 1]) {
                left[i] = left[i - 1] + 1;
            }
        }
        //从右到左比较，满足当前位置比右边分数高就要比右边多一个糖果
        for(int i = right.length - 2; i >= 0; i--) {
            if(ratings[i] > ratings[i + 1]) {
                right[i] = right[i + 1] + 1;
            }
        }
        //取两次的最大值
        for(int i = 0; i < result.length; i++) {
            result[i] = Math.max(left[i], right[i]);
            sum += result[i];
        }
        return sum;
    }
}
```

## [860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)

在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。

**示例 1：**

```
输入：bills = [5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。
```

**示例 2：**

```
输入：bills = [5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。 
```

**提示：**

- `1 <= bills.length <= 105`
- `bills[i]` 不是 `5` 就是 `10` 或是 `20` 

**仔细一琢磨就会发现，可供我们做判断的空间非常少！**

只需要维护三种金额的数量，5，10和20。

有如下三种情况：

- 情况一：账单是5，直接收下。
- 情况二：账单是10，消耗一个5，增加一个10
- 情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5

此时大家就发现 情况一，情况二，都是固定策略，都不用我们来做分析了，而唯一不确定的其实在情况三。

而情况三逻辑也不复杂甚至感觉纯模拟就可以了，其实情况三这里是有贪心的。

账单是20的情况，为什么要优先消耗一个10和一个5呢？

**因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！**

所以**局部最优：遇到账单20，优先消耗美元10**，完成本次找零。全局最优：完成全部账单的找零。

局部最优可以推出全局最优，并找不出反例，那么就试试贪心算法！

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int cash10 = 0;
        int cash5 = 0;
        int balance = 0;
        for(int i = 0; i < bills.length; i++) {
            if(bills[i] == 5) {
                cash5++;
                balance += 5;
            } else if(bills[i] == 10) {
                if(cash5 == 0) {
                    return false;
                } else {
                    cash5--;
                    cash10++;
                    balance += 5;
                }
            } else {//给20的情况
                if(cash5 * 5 + cash10 * 10 < 15 || cash5 == 0) {
                    return false;
                } else if(cash10 > 0) {//遇到20，有10先找零10，因为
                //5可以给账单10和账单20找零，美元5更万能
                    cash10--;
                    cash5--;
                    balance += 5;
                } else {
                    cash5 -= 3;
                    balance += 5;
                }
            }
        }
        return true;
    }
}
```

