# 计算机网络

------

## OSI 七参考模型

**OSI 七层模型** 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：

<img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220328170810681.png" alt="image-20220328170810681" style="zoom:80%;" />

- **应用层(Application Layer)：**由用户自己规定，**规定各个应用之间消息传递的形式**等，包括各机互访协议，分布式数据库协议等。常见的应用层协议有**HTTP协议和FTP**等。
- **表示层(Presentation Layer)：**在满足用户需求的基础上，尽可能的节省传输费用而设置的，比如传输压缩文件，jpeg或者加密文件等格式。
- **会话层(Session Layer)：**用于建立和拆除会话。
- **传输层(Transport Layer)：**负责将来自会话层的消息传递给网络层，**常见的传输层协议有TCP和UDP等协议。**
- **网络层（Network Layer）：**规定通信网内的路由选择等方式，建立用户间的信息报传输设施。常见的网络层协议有IP，ICMP以及ARP等协议。
- **数据链路层（Data Link Layer）：**与建立数据传输链路相关。
- **物理层（Physical Layer）：**规定一些机电性能，也包括工作方式如双工、单工或半双工，建立通信的启动和终止等。

🔥🔥🔥记忆技巧：**P**lease  **D**o  **N**ot  **T**ell  **S**tupid  **P**eople  **A**nything

## TCP/IP 四层模型

**TCP/IP 四层模型** 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：

1. 应用层
2. 传输层
3. 网络层
4. 网络接口层

需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：

<img src="https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220328171605011.png" alt="image-20220328171605011" style="zoom:80%;" />

### TCP/IP协议

TCP/IP协议**即传输控制/网络协议，也叫作网络通讯协议。**是一系列网络协议的总称，是网络通信的基本骨架。TCP/IP协议模型在OSI七层模型的基础上，通过合并的方式，简化为**四层**，分别为**应用层，传输层，网络层以及网络接口层**。

### 应用层（Application layer）

**应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。** 我们把应用层交互的数据单元称为报文。应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 **HTTP 协议**，支持电子邮件的 **SMTP 协议**、**FTP文件传输协议**等等。

#### HTTP:超文本传输协议

**超文本传输协议（HTTP，HyperText Transfer Protocol)** 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。

HTTP 协是基于 TCP协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。

另外， HTTP 协议是”**无状态**”的协议，它**无法记录客户端用户的状态**，一般我们都是通过 **Session** 来记录客户端用户的状态。

#### SMTP:简单邮件传输(发送)协议

**简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）** 基于 TCP 协议，用来发送电子邮件。

注意⚠️：**接受邮件的协议不是 SMTP 而是 POP3 协议。**

#### POP3/IMAP:邮件接收的协议

这两个协议没必要多做阐述，只需要了解 **POP3 和 IMAP 两者都是负责邮件接收的协议**即可。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。**SMTP 协议只负责邮件的发送，真正负责接收的协议是POP3/IMAP。**

#### FTP:文件传输协议

**FTP 协议** 主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。

> FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：
>
> 1. 控制连接：用于传送控制信息（命令和响应）
> 2. 数据连接：用于数据传送；
>
> 这种将命令和数据分开传送的思想大大提高了 FTP 的效率。

![image-20220329094215328](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220329094215328.png)

#### Telnet:远程登陆协议

**Telnet 协议** 通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。

#### SSH:安全的网络传输协议

**SSH（ Secure Shell）** 是目前较可靠，专为**远程登录会话**和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。

**Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性。**

### 传输层（Transport layer）

一句话，就是**建立端到端的连接。**

传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。

**传输层主要使用以下两种协议：**

#### TCP

- **传输控制协议 TCP**（Transmisson Control Protocol）--提供**面向连接**的，**可靠的**数据传输服务。

#### UDP

- **用户数据协议 UDP**（User Datagram Protocol）--提供**无连接**的，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）。

### 网络层（Network layer）

**网络层负责为分组交换网上的不同主机提供通信服务。** 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。

注意 ⚠️：**不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混**。

**网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分株，能通过网络层中的路由器找到目的主机。**

这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。

互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做**网际层**或**IP 层**。

#### IP协议

IP协议制定了一套网络地址，也就是IP地址，**根据IP协议能够区分两台主机是否同属一个网络（子网）**。

#### 路由协议

**ARP的寻址必须是在同一个子网内**，我们可以通过IP协议来确定是否是同一个子网。如果不是同一个子网，则通过**网关**将数据包多次转发到对应的子网中，完成这个路由协议的物理设备就是路由器。

### 网络接口层（Network interface layer）

我们可以把网络接口层看作是数据链路层和物理层的合体。

1. 数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。**数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。**
2. **物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异**

#### ARP协议（地址解析协议）

**根据IP地址获取MAC地址，**将目标的IP地址在链路层进行包装，生成以太网数据包，在同一个子网内进行广播出去，**各个主机拿到IP地址和自己的IP地址对比，若一样，则返回自己的MAC地址。**注意，MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间。

## 为什么网络要分层？

1. **各层之间相互独立**：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）**。这个和我们对开发时系统进行分层是一个道理。**
2. **提高了整体灵活性** ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。**这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。**
3. **大问题化小** ： 分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 **这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。**

## HTTP协议

**超文本传输协议（HTTP，HyperText Transfer Protocol)** 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。

HTTP 协是**基于 TCP协议**，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。

另外， HTTP 协议是”**无状态**”的协议，它**无法记录客户端用户的状态**，一般我们都是通过 **Session** 来记录客户端用户的状态。

#### HTTP 常⻅的状态码

![image-20220329095513637](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220329095513637.png)

- **1xx**

1xx 类状态码属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。

- **2xx**

2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。

「200 OK」是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body 数据。

「204 No Content」也是常⻅的成功状态码，与 200 OK 基本相同，但**响应头没有 body 数据**。  

「206 Partial Content」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽
是其中的⼀部分，也是服务器处理成功的状态。

- **3xx**

3xx 类状态码表示客户端请求的资源发生了变动，需要客户端⽤新的 URL 重新发送请求获取资源，也就是**重定**
**向。**

「301 Moved Permanently」表示**永久重定向**，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。

「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。

301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动重定向新的 URL。

「304 Not Modified」不具有跳转的含义，表示资源未修改，**重定向已存在的缓冲⽂件，也称缓存重定向**，⽤于缓
存控制。

305状态码代表的意思是 **必须通过代理访问**

- **4xx**

4xx 类状态码表示**客户端发送的报⽂有误，服务器⽆法处理**，也就是错误码的含义。

「400 Bad Request」表示**客户端请求的报⽂有错误**，但只是个笼统的错误。

「403 Forbidden」表示**服务器禁⽌访问资源**，并不是客户端的请求出错。

「404 Not Found」表示**请求的资源在服务器上不存在或未找到**，所以⽆法提供给客户端。

- **5xx**

5xx 类状态码表示客户端请求报⽂正确，但是**服务器处理时内部发⽣了错误，属于服务器端的错误码**。

「500 Internal Server Error」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。

「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。

「502 Bad Gateway」通常是**服务器作为⽹关或代理时返回的错误码**，表示服务器⾃身⼯作正常，访问后端服务器
发⽣了错误。

「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后重试”的意
思。  

#### http 常⻅字段有哪些？  

- **Host 字段**  

客户端发送请求时，⽤来指定服务器的域名。  

- **Content-Length 字段**

**服务器在返回数据时**，会有 Content-Length 字段，表明本次响应的数据⻓度。  

- Content-Type 字段

Content-Type 字段⽤于服务器回应时，告诉客户端，本次数据是什么**格式**。  

#### 说⼀下 GET 和 POST 的区别？  

Get ⽅法的含义是**请求从服务器获取资源**，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。  

POST ⽅法则是相反操作，它**向服务器修改数据**，数据就放在报⽂的 body ⾥。  

下面的表格比较了两种 HTTP 方法：GET 和 POST。

|                  | GET                                                          | POST                                                         |
| :--------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 后退按钮/刷新    | 无害                                                         | 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。     |
| 书签             | 可收藏为书签                                                 | 不可收藏为书签                                               |
| 缓存             | 能被缓存                                                     | 不能缓存                                                     |
| 编码类型         | application/x-www-form-urlencoded                            | application/x-www-form-urlencoded or multipart/form-data。为二进制数据使用多重编码。 |
| 历史             | 参数保留在浏览器历史中。                                     | 参数不会保存在浏览器历史中。                                 |
| 对数据长度的限制 | 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的 | 无限制。                                                     |
| 安全性           | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。  在发送密码或其他敏感信息时绝不要使用 GET ！ | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 |

🔥🔥🔥注：

常听到GET不如POST安全，因为POST用body传输数据，而GET用url传输，更加容易看到。但是从攻击的角度，无论是GET还是POST都不够安全，因为HTTP本身是**明文协议**。**每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body**。为了避免传输中数据被窃取，**必须做从客户端到服务器的端端加密。业界的通行做法就是https**——即用SSL协议协商出的密钥加密明文的http数据

对数据长度的限制**准确来说是URL 长度有限制，但HTTP协议对URL没做规定，实际的限制是由客户端/浏览器以及服务器端决定的。**）**Chrome的URL限制是2MB。**

**如何避免表单重复提交？**

**注解 + AOP**。通过在自定义注解里定义一些相关的字段，比如过期时间即该时间内同一用户不能重复提交请求。然后把注解按需加在接口上，最后在拦截器里判断接口上是否有该接口，如果存在则拦截。

**GET 和 POST ⽅法都是安全和幂等的吗？**  

**先说明下安全和幂等的概念：**

- 在 HTTP 协议⾥，所谓的**「安全」是指请求⽅法不会「破坏」服务器上的资源**。
- 所谓的「幂等」，意思是**多次执⾏相同的操作，结果都是「相同」的**。

那么很明显 GET ⽅法就是**安全且幂等的**，因为它是「只读」操作，⽆论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。

POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全的**，且多次提交数据就会创建多个资源，  所以**不是幂等的**。  不幂等也就意味着不能随意多次执行。因此也就**不能缓存**。

#### URI、URL、URN概念

- URI = Uniform Resource Identifier 统一资源**标志符**
- URL = Uniform Resource Locator 统一资源**定位符**
- URN = Uniform Resource Name 统一资源名称

简单来说，就是URI是抽象的定义，不管用什么方法表示，只要能定位一个资源，就叫URI。

URI是指资源在世界上唯一的标识符，包括两种标识形式，一种是用资源的地址来标识`(URL)`，一种是用资源的名称来标识`(URN)`。若用名称标识时，在访问资源时，还要先用一个解析器找到该名称对应的地址，然后再访问。

![image-20220329113030855](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220329113030855.png)



## TCP 三次握手和四次挥手

### TCP头部

![image-20220404110318676](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220404110318676.png)

> SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。

### 建立TCP连接

三次握手 (Three-way Handshake)，是指 **建立一个 TCP 连接时，需要客户端和服务器总共发送3个包**。

TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！

#### **TCP连接握手，握的是啥（TCP三次握手的核心）？**

通信双方**数据原点的序列号**，也就是利用报文段交换双方的**初始化序列号**（Initial sequence number）！

**TCP可靠传输的精髓**：TCP连接的一方A，由操作系统动态随机选取一个**32位长的序列号（Initial Sequence Number），**假设A的初始序列号为1000，**以该序列号为原点**，对自己将要发送的每个字节的数据进行编号，1001，1002，1003…，并把自己的初始序列号ISN告诉B，让**B有一个思想准备，什么样编号的数据是合法的，什么编号是非法的**，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。

同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003…，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。

以此核心思想我们来分析二、三、四次握手的过程。

> SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。

A <----------------> B

#### **三次握手的过程**

**1.1** A 发送同步信号**SYN** + **A's Initial sequence number**

**1.2** B 确认收到A的同步信号，并记录A's ISN 到本地，命名 **B's ACK sequence number（发送ACK信号给A）**

**1.3** B发送同步信号**SYN** + **B's Initial sequence number **

**1.4** A确认收到B的同步信号，并记录B's ISN 到本地，命名 **A's ACK sequence number（发送ACK信号给B）**

很显然1.2和1.3 这两个步骤可以合并，**只需要三次握手，**可以提高连接的速度与效率。

![image-20220404101337696](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220404101337696.png)

ACK = 1是将 TCP 头部 中的 ACK位 置为 1，ack为服务器发回的确认号

![image-20220404113155758](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220404113155758.png)

![image-20220404104508060](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220404104508060.png)

上图中，为什么 确认号需要 加 1？？

因为 SYN = 1 和  FIN = 1 要消耗掉一个序号。ACK如果不携带数据，则不消耗序列号。

#### 第 2 次握手传回了 ACK，为什么还要传回 SYN？

接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了**建立并确认从服务端到客户端的通信。**

#### **两次握手的过程**

**2.1** A 发送同步信号**SYN** + **A'sInitial sequence number**

**2.2** B发送同步信号**SYN** + **B'sInitial sequence number** + **B's ACK sequence number**

这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。**但是**B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，**A和B就B的初始序列号将无法达成一致**，也就是从服务端到客户端的通信还没有确立。

如果A发给B的确认丢了，该如何？A会超时重传这个ACK吗？

不会！**TCP不会为没有数据的ACK超时重传**。

那该如何是好？**B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。**

#### 两次握手会出现的问题

如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时**客户端忽略服务端发来的确认**（序列号过期或超时），也不发送数据，则**服务端一致等待客户端发送数据，浪费资源。**

### 断开TCP连接

双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。

![image-20220404111554153](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220404111554153.png)

#### TCP四次挥手过程

1. 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
2. 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSED_WAIT` 状态。客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
3. 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
4. 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态

服务器收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。

客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

#### **四次挥手释放连接时，等待2MSL的意义?**

**MSL表示最大报文生存周期 （ Maximum Segment Lifetime）**，任何报文在网络上存在的最长时间，**超过这个时间报文将被丢弃**。2MSL 的时间是从**[客户端](https://www.zhihu.com/search?q=客户端&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2005038284})接收到 FIN 后发送 ACK 开始计时的**。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 **2MSL 时间将重新计时**。

主动断开方（A）的最后一次 ACK 报文在发送后会有两种情况：

1. ACK报文在网络中丢失

   B没有收到自己的ACK，会超时重传FIN。那么A再次接到重传的FIN，会再次发送ACK

2. ACK报文被B接收到。

   我们假设A发送了ACK报文后过了一段时间t之后B才收到该ACK，则有 0 < t <= MSL。因为A并不知道它发送出去的ACK要多久对方才能收到，所以A至少要维持MSL时长的TIME_WAIT状态才能保证它的ACK从网络中消失。同时处于LAST_ACK状态的B因为收到了ACK，所以它直接就进入了CLOSED状态，而不会向网络发送任何报文。所以晃眼一看，A只需要等待1个MSL就够了，但仔细想一下其实1个MSL是不行的，因为在B收到ACK前的一刹那，B可能因为没收到ACK而重传了一个FIN报文，这个FIN报文要从网络中消失最多还需要一个MSL时长，所以A还需要多等一个MSL。

   无论是1还是2，A都需要等待，要取这两种情况等待时间的最大值，**以应对最坏的情况发生**，这个最坏情况是：去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。

综上所述，**TIME_WAIT至少需要持续2MSL时长，这2个MSL中的第一个MSL是为了等自己发出去的最后一个ACK从网络中消失，而第二MSL是为了等在对端收到ACK之前的一刹那可能重传的FIN报文从网络中消失。**

- 保证客户端发送的最后一个ACK报文段能够到达服务端。

这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到`CLOSED`状态。

- 防止“已失效的连接请求报文段”出现在本连接中。

客户端在发送完最后一个ACK报文段后，再经过2MSL，就**可以使本连接持续的时间内所产生的所有报文段都从网络中消失**，使下一个新的连接中不会出现这种旧的连接请求报文段。



## TCP和UDP 协议的区别

![image-20220406113142766](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220406113142766.png)

UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。

TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。



## Cookie、Session、Token究竟区别在哪？如何进行身份认证，保持用户登录状态？

**Cookie**

**cookie的由来：**因为`HTTP`协议是不保存状态的，所以服务器端不知道是不是同一个浏览器在访问它，所以设置了cookie来进行辨认。
客户端自身是没有cookie的，当客户端第一次请求服务器端时，服务器端响应时，顺便通过`set-cookie`设置`cookie`放在**响应头**里发给客户端，之后客户端每次请求时默认携带cookie。

![image-20220329115737695](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220329115737695.png)

Cookie是 Http 协议中定义在 header 中的字段。

但是由于cookie 是存在客户端，而且它本身存储的尺寸大小也有限，最关键是用户可以是可见的，并可以随意的修改，很不安全。

**Session**

![image-20220329120242735](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220329120242735.png)

以基于Java的会话为例，，当一个会话开始时，`Servlet容器`会创建一个`HttpSession`对象，`HttpSession`对象中可以存放客户状态的信息。`Servlet容器`会为每个`HttpSession`对象分配一个唯一标识符，也就是`Session ID`。

当一个浏览器进程第一次请求访问服务器时候，Servlet容器会试图寻找HTTP请求中表示Session ID的Cookie，由于还不存在Cookie，就认为开始一个新的会话，于是创建一个HttpSession对象，为它分配唯一的Session ID，然后把 Session ID 作为Cookie添加到HTTP相应中。浏览器接受到HTTP响应结果后，就会把Cookie保存至客户端。

**session保存在服务端。cookie保存在客户端,并且cookie有大小限制。**

**Token**

![image-20220329120807378](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220329120807378.png)

## HTTP vs HTTPS

HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol），主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。

HTTP 是**应用层协议**，它以 **TCP（传输层）作为底层协议**，默认端口为 80。

HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用` SSL/TLS `协议用作加密和安全认证。默认端口号是 443. 

- OSI 模型不适用于SSL，不能100％准确的说在哪个位置。只能表示SSL的大概位置。用于帮助理解。
- SSL 作用于应用层和运输层之间。如果硬要说在哪个位置，那就是：会话层

利用非对称加密 +  对称加密 + 数字证书共同来保证安全性。

### **非对称加密+对称加密？**

既然非对称加密耗时，那非对称加密+对称加密结合可以吗？而且得尽量减少非对称加密的次数。当然是可以的，且非对称加密、解密各只需用一次即可。
请看一下这个过程：

1. 某网站拥有用于非对称加密的公钥A、私钥`A'`。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。
4. 服务器拿到后用私钥`A'`解密得到密钥X。
5. 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。

完美！HTTPS基本就是采用了这种方案。完美？还是有漏洞的。

### **中间人攻击**

![image-20220403211945923](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220403211945923.png)



如果在数据传输过程中，中间人劫持到了数据，此时他的确无法得到浏览器生成的密钥X，这个密钥本身被公钥A加密了，只有服务器才有私钥A’解开它，然而中间人却完全不需要拿到私钥A’就能干坏事了。请看：

1. 某网站有用于非对称加密的公钥A、私钥A’。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. **中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）**。
4. 浏览器生成一个用于对称加密的密钥X，用**公钥B**（浏览器无法得知公钥被替换了）加密后传给服务器。
5. **中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器**。
6. 服务器拿到后用私钥A’解密得到密钥X。

这样在双方都不会发现异常的情况下，中间人通过一套“狸猫换太子”的操作，掉包了服务器传来的公钥，进而得到了密钥X。**根本原因是浏览器无法确认收到的公钥是不是网站自己的，**因为公钥本身是明文传输的。

### **如何证明浏览器收到的公钥一定是该网站的公钥？**

使用**数字证书**来证明上述的浏览器拿到的公钥是可靠的。网站在使用HTTPS前，需要向**CA机构**申领一份**数字证书**，数字证书里含有**证书持有者信息、公钥信息**等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”。

那么，现在问题又变成了**如何证明证书本身的真实性**？  =====>  **数字签名** 

**数字签名的制作过程：**

1. CA机构拥有非对称加密的私钥和公钥。
2. CA机构对证书明文数据T进行hash。
3. 对hash后的值用私钥加密，得到数字签名S。

明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。
那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）

![image-20220403212402978](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220403212402978.png)

**浏览器验证过程：**

1. 拿到证书，得到明文T，签名S。
2. 用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。
3. 用证书里指明的hash算法对明文T进行hash得到T’。
4. 显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。

![image-20220403212335869](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220403212335869.png)

### **中间人有可能篡改该证书吗？**

由上述知识得知，数字证书由证书明文T，签名S构成。

假设中间人篡改了证书的原文，由于他没有CA机构的私钥，他自己伪造的加密签名和利用CA机构的私钥加密的签名是不一样的，是无法相应地篡改经过CA机构私钥加密的签名的。

因为，浏览器收到该证书后会利用CA机构的公钥对加密的前面进行解密，就会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。

### **中间人有可能把证书掉包吗？**

其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。

### **为什么制作数字签名时需要hash一次？**

我初识HTTPS的时候就有这个疑问，因为似乎那里的hash有点多余，把hash过程去掉也能保证证书没有被篡改。

最显然的是性能问题，前面我们已经说了**非对称加密效率较差，证书信息一般较长，比较耗时**。**而hash后得到的是固定长度的信息**（比如用md5算法hash后可以得到固定的128位的值），这样加解密就快很多。

### **怎么证明CA机构的公钥是可信的？**

操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有CA机构的根证书，这样就可以拿到它对应的可信公钥了。

证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做`信任链`或`数字证书链`。也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。

此外，利用系统根证书和`信任链`或`数字证书链`机制，也可以拿到**验证数字证书**的CA机构的公钥。

### 总结

数字证书为了保证 非对称加密+对称加密 方案中 **密钥 X**的可靠性，即密钥X没有被中间人劫持篡改，而数字证书的可靠性又由 `数字签名` 和 `CA机构`来保证。

## 在浏览器中输入 url 地址到显示主页的过程 （会使用哪些协议）

总体来说分为以下几个过程:

1. DNS 解析:将域名解析成 IP 地址

   在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。

   - 浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。
   - 操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。（Windows的hosts文件）
   - 路由缓存：路由器也有 DNS 缓存。
   - **ISP 的 DNS 服务器**：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。
   - **根服务器**：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行**递归查询**（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）

2. TCP 连接：**TCP 三次握手**

   将解析的 IP地址打在协议上发送给服务器，通过三次挥手建立TCP连接。

3. 发送 HTTP 请求

4. 服务器处理请求并返回 HTTP 响应报文

5. 浏览器解析渲染页面

6. 断开连接：**TCP 四次挥手**

![image-20220406155820912](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220406155820912.png)

## HTTP 1.0 vs HTTP 1.1区别

1. **连接方式** : 

   **HTTP 1.0 为默认短连接。**客户端和服务器**每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接**。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个TCP连接，这样就会导致**有大量的“握手报文”和“挥手报文”占用了带宽**。

   **HTTP 1.1 默认为长连接。**采用长连接模式的请求报文会通知服务端：“我向你请求连接，并且连接成功建立后，请不要关闭”。因此，该TCP连接将持续打开，为后续的客户端-服务端的数据交互服务。也就是说在使用长连接的情况下，当一个网页打开完成后，**客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。**

   如果 TCP 连接一直保持的话也是对资源的浪费，因此，一些服务器软件（如 Apache）还会支持**超时时间**的时间。在超时时间之内没有新的请求达到，TCP 连接才会被关闭。

   HTTP/1.0仍提供了长连接选项，即在请求头中加入`Connection: Keep-alive`。同样的，在HTTP/1.1中，如果不希望使用长连接选项，也可以在请求头中加入`Connection: close`

   **HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。**

   **实现长连接需要客户端和服务端都支持长连接。**

2. **状态响应码** : HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，`100 (Continue)`——在请求大资源前的**预热请求**，`206 (Partial Content)`——范围请求的标识码，`409 (Conflict)`——**请求与当前资源的规定冲突**，**`410 (Gone)`——资源已被永久转移，而且没有任何已知的转发地址。**

3. **缓存处理** : 

   **在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准**。HTTP/1.0提供的缓存机制非常简单。服务器端使用`Expires`标签来标志（时间）一个响应体，在`Expires`标志时间内的请求，都会获得该响应体缓存。服务器端在初次返回给客户端的响应体中，有一个`Last-Modified`标签，该标签标记了被请求资源在服务器端的最后一次修改。在请求头中，使用`If-Modified-Since`标签，该标签标志一个时间，意为客户端向服务器进行问询：“该时间之后，我要请求的资源是否有被修改过？”通常情况下，请求头中的`If-Modified-Since`的值即为上一次获得该资源时，响应体中的`Last-Modified`的值。

   如果服务器接收到了请求头，并判断`If-Modified-Since`时间后，资源确实没有修改过，则返回给客户端一个`304 not modified`响应头，表示”缓冲可用，你从浏览器里拿吧！”。

   如果服务器判断`If-Modified-Since`时间后，资源被修改过，则返回给客户端一个`200 OK`的响应体，并附带全新的资源内容，表示”你要的我已经改过的，给你一份新的”。

   ![image-20220407102920910](https://ykangliblog.oss-cn-beijing.aliyuncs.com/article/image-20220407102920910.png)

   HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。

4. **带宽优化及网络连接的使用** :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且**不支持断点续传功能**，HTTP1.1 则在请求头引入了**范围请求（range request）机制**，它**允许只请求资源的某个部分，即返回码是 206**（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

5. **Host头处理** : HTTP/1.1在请求头中加入了`Host`字段。

   HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在**一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址**。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础